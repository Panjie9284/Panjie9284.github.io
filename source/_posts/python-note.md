---
title: python_note
date: 2023-07-12 14:26:04
tags: python
categories: note
diytitle:
  enable: true
  leaveTitle: w(ﾟДﾟ)w 不要走！再看看嘛！
  backTitle: ♪(^∇^*)欢迎肥来！
cover: https://pic4.zhimg.com/80/v2-50b2b4132aeafddb382ca20c839d23d7_720w.webp
---

# 变量
## 1.命名规则
- 可以包含字母、数字、下划线。
- 不能以数字开头
- 变量名中不能包含空格
- 不能和关键名同名
- 不要和内置函数相同

与cpp相同

# 注释
不同于cpp使用//，而是使用#

# 字符串
## 1.字符串定义  
"你好"
'''你好'''
"""你好"""  
这些定义字符串都是正确的  
'''定义可以支持换行  
## 2.字符串中的元素  
从0开始，每一位对应一个元素且有唯一的序号  
hello = '你好！'  
hello[0] = '你'  
len(hello)可以获取到hello字符长度  
还可以使用反向来获得到字符串元素的序号  
hello[-1] = '！'  
## 3.切片  
hello[1:2] = '好！'  
[:x] 从0到x位  
[-x:] 从倒数-x位到最后一位  

# 函数
## 1.定义函数
**def 函数名():**  
····内容
    
## 2.函数的参数
函数名(**para1，para2**)  
**缺省值**:在(para1,para2=60),若没传入para2，则para2 会默认为60

## 3.函数的返回值
return 返回值  
如果没写则返回的是None  
  
# 列表和元组
## 1.使用[]来表示一个列表
每个存储格可以存储任何类型的对象  
sequence操作（切片操作）  
## 2.元组
可理解为内容不能改变的列表  
使用()来定义  
a(1,)为元组  
a(1)为数字1  

# bool对象
与cpp相同只有true和false  
**&** 变成关键字 **and** 运算理解为电路中的串联  
**|** 变成关键字 **or** 运算理解为电路中的并联  
not > and > or  

# 判断语句
if 条件 :  
····内容  
elif 条件2 :  
····内容  
else:  
····内容  

# 对象的方法
eg.  
var1 = [1,2,3,4,5,6,7]  
var1.reverse()  
此时var1 = [7,6,5,4,3,2,1]  
调用对象的方法就是调用函数  

# 字符串的方法

## **1.count**  
count方法可以返回字符串对象包含了多少个参数指定的字符串  
字面量：直接将数据对象写出来，如'你好'  

## **2.find**  
find方法会在字符串中查找参数子字符串，并返回参数字符串在其第一个出现的位置索引  

对象.find('查找对象'，寻找起始位置)  

## **3.split**  
经常用来从字符串中截取出文明想要的信息  
split方法以参数字符串为分隔符，将只发出切割为多个字符串，作为元素存入一个列表，并返回这个列表。  

## **4.join**  
与plit正好相反jion是将列表中的字符串元素以某个字符串为连接符，连接为一个字符串  

## **5.strip、lstrip、rstrip**  
对象.strip()去掉字符串两侧的空格，去除左侧的空格，去除右侧空格，字符串中间的空格不会去除   

## **6.replace**  
replace也是常用的方法，用来替换字符串里面所有指定的子字符串为另一个字符串  
对象.replace('指定子字符串', '替换对象')  

## **7.startswith和endswith**  
startswith方法检查字符串是否以参数指定的字符串开头，如果是，返回true，否则返回false  
endswith方法检查字符串是否以指定的字符串结尾，如果是返回true，否则返回false  

# 列表的方法
重点强调**列表就是一种内容可以改变的对象**  

## **1.append**
在对象末尾添加一个元素  
对象.append(添加的内容)  

## **2.insert**
在指定位置插入一个元素  
对象.insert(指定位置的索引,添加的内容)  

## **3.pop**
从列表中取出并删除一个元素  
对象.pop(删除元素的索引)  

## **4.remove**
只删除对象中第一个指定元素  
对象.remove('指定元素')  
知道要删除元素的位置时使用pop的效率高  

## **5.reverse**
将对象的元素反过来  
对象.reverse()  

# 格式化字符串

## **1.printf**
print('税前薪资：%s元，缴税：%s元，税后薪资：%s元' %(salary,tax,aftertax))  
基本语法同c语言  

## **2.f-string**
print(f'税前薪资是：{salary}元， 缴税：{tax}元， 税后薪资是：{aftertax}元')  

### 指定宽度
salary = 10000  
print(f'{salary:10}')  

### 左右对齐
上面的输出结果是不足在前面补空格，对于数字对象来说，缺省为 右边对齐，而字符串缺省为 左边对齐 。  
f"|{'abc':10}|{300:10}|"  
'|abc       |       300|'  
f"|{'abc':>10}|{300:<10}|"  
'|       abc|300       |'  

### 小数点后位数
如果我们想指定小数点后保留几位，可以像这样 {salary:<8.1f}
   
### 不足补零
如果我们想在不足指定宽度的时候不是补空格，而是补数字0，可以像这样 {salary:08}  

### 16进制格式化数字
#用 x 表示格式化为16进制，并采用小写格式  
f'数字65535的16进制表示为：{65535:x}'  

#用 X 表示格式化为16进制，并采用大写格式  
f'数字65535的16进制表示为：{65535:X}'

### 字符串内容里有花括号
采用f-string 方式格式化的字符串内容本身就有{或者}符号,一定要双写进行转义，否则会被当成是格式化占位符。

# 循环
python中有while循环和for循环  

## while 条件 :

## for i in range:
从一个容器中取出每个元素进行操作  

## 循环n次
for n in range(50，101):  python中都是左闭右开  
循环100次的示例  

## break
终止循环  

## continue
只结束当前这一次循环，然后  

## 列表推导式
list1 = [1,2,3,4,5,6]
list2 = [num**3 for num in list1]

## 循环嵌套
多重循环，类比cpp

# 字符编码（属于了解常识类）

## 字符集
ASCII码表  

## 字符编码

## 待补充

# 文本读写
```python
open(
    file, 
    mode='r', 
    buffering=-1, 
    encoding=None, 
    errors=None, 
    newline=None, 
    closefd=True, 
    opener=None
    ) 
```
其中下面这3个参数是我们常用的。

- 参数 file

  file参数指定了要打开文件的路径。

  可以是相对路径，比如 ’log.txt’， 就是指当前工作目录下面的log.txt 文件 也可以是绝对路径，比如 ’d:\project\log\log.txt’，


- 参数 mode

  mode参数指定了文件打开的 模式 ，打开文件的模式 决定了可以怎样操作文件。

  常用的打开模式有

  - r 只读文本模式打开，这是最常用的一种模式

  - w 只写文本模式打开

  - a 追加文本模式打开

  如果我们要 读取文本文件内容到字符串对象中 ， 就应该使用 r 模式。

  我们可以发现mode参数的缺省值 就是 ‘r’ 。

  就是说，调用open函数时，如果没有指定参数mode的值，那么该参数就使用缺省值 ‘r’，表示只读打开。

  如果我们要 创建一个新文件写入内容，或者清空某个文本文件重新写入内容， 就应该使用 ‘w’ 模式。

  如果我们要 从某个文件末尾添加内容， 就应该使用 ‘a’ 模式。


- 参数 encoding

  encoding 参数指定了读写文本文件时，使用的 字符编解码 方式。

  调用open函数时，如果传入了encoding参数值：

    后面调用write写入字符串到文件中，open函数会使用指定encoding编码为字节串；

    后面调用read从文件中读取内容，open函数会使用指定encoding解码为字符串对象

  如果调用的时候没有传入encoding参数值，open函数会使用系统缺省字符编码方式。 比如在中文的Windows系统上，就是使用cp936（就是gbk编码）。

  建议大家编写代码 读写文本文件时，都指定该参数的值。

## 再补充

# **模块和库**
根据不同代码功能放在不同的文件里  

## import 文件名
导入一个模块名字  

## from 模块 import 函数对象

## 一些技巧
import flie1, file2, file3  

from aa import func1, var1, func2, var2

## 将模块放入包中
```
stock/                        ---   顶层包
        __init__.py           ---   stock包的初始化文件
        food/                 ---   food子包
                __init__.py
                pork.py
                beef.py
                lobster.py
                ...
        furniture/            ---   furniture子包
                __init__.py
                bed.py
                desk.py
                chair.py
                ...
        kitchen/              ---   kitchen子包
                __init__.py
                knife.py
                pot.py
                bowl.py
```

## 库的概念
如果你写的模块文件里面的函数，实现了通用的功能，经常被其它模块所调用，我们就可以把这些被调用的模块文件称之为**库** 
库是个抽象的概念，只要 某个模块或者一组模块 ，开发它们的目的就是给其它模块调用的，就可以称之为库。